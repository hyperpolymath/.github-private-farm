= RSR Roadmap: From Foundation to v10+
Jonathan D.A. Jewell <jonathan@hyperpolymath.org>
v0.2.0, 2025-12-23
:toc: macro
:toc-title: Contents
:toclevels: 4
:icons: font
:source-highlighter: rouge
:experimental:
:sectnums:
:sectanchors:

[.lead]
*A vision for transforming RSR from a template repository into a decentralised trust infrastructure for ethical software development.*

toc::[]

== Executive Summary

RSR (Rhodium Standard Repository) begins as a templateâ€”a collection of best practices, CI workflows, and consent declarations. By v10.0, it becomes *infrastructure*: a self-enforcing trust network where security, consent, and provenance are not optional policies but cryptographically verifiable properties of the software itself.

[quote, The Goal]
____
Make ethical software development the path of least resistance.
____

== Current State (v0.x â†’ v1.0)

=== What Exists Today

[cols="1,1,2", options="header"]
|===
| Component | Status | Description

| Template Structure
| âœ… Complete
| Standard directory layout, required files, .well-known/

| CI Workflows
| âœ… Complete
| CodeQL, Dependabot, RSR anti-pattern, security validation

| Consent Framework
| âœ… Declaration
| `.well-known/ai.txt`, `consent-required.txt` (not yet enforced)

| Provenance
| ðŸŸ¡ Partial
| `provenance.json`, `codemeta.json` (not yet attested)

| Language Policy
| âœ… Enforced
| CI blocks TypeScript, Go, Python (except SaltStack)

| Security Policy
| âœ… Complete
| SECURITY.md template, RFC 9116 compliance checking
|===

=== v1.0 Milestone: Foundation Complete

*Target*: Template ready for production use across the hyperpolymath ecosystem.

.Remaining Work
* [ ] justfile with 50+ recipes
* [ ] Containerfile template (Podman-native)
* [ ] flake.nix template
* [ ] STATE.scm tooling integration
* [ ] Pre-commit hooks package
* [ ] Documentation site (GitHub Pages)

---

== Phase 1: Self-Enforcing Trust (v2.0)

=== Vision

Transform RSR from passive policies to active enforcement. Projects don't just *declare* complianceâ€”they *prove* it.

=== Key Features

==== 2.1 Compliance Attestation

Every RSR-compliant project generates cryptographic attestations:

[source,json]
----
{
  "@context": "https://slsa.dev/attestation/v1",
  "predicateType": "https://rhodium.sh/rsr-compliance/v2",
  "predicate": {
    "rsrVersion": "2.0.0",
    "tier": 1,
    "checks": {
      "languagePolicy": { "passed": true, "violations": [] },
      "securityPolicy": { "passed": true, "score": 9.2 },
      "consentPolicy": { "passed": true, "level": 4 },
      "provenanceChain": { "passed": true, "depth": 12 }
    },
    "attestedAt": "2026-03-15T10:30:00Z",
    "attestedBy": "sigstore.dev"
  }
}
----

==== 2.2 Cross-Project Reputation

Projects form a *web of trust*:

* Projects that depend on RSR-compliant dependencies earn reputation
* Non-compliant dependencies trigger warnings/blocks
* Reputation scores are public and verifiable

[plantuml, reputation-graph, svg]
....
@startuml
!theme plain
skinparam backgroundColor transparent

package "RSR Trust Graph" {
  [Project A\nTier 1, Score 9.5] as A
  [Project B\nTier 1, Score 8.8] as B
  [Project C\nTier 2, Score 7.2] as C
  [Project D\nNon-RSR] as D

  A --> B : trusts
  A --> C : trusts
  B --> C : trusts
  C ..> D : warns
}

note right of D
  Non-RSR dependencies
  trigger warnings in
  dependent projects
end note
@enduml
....

==== 2.3 Automated Compliance Inheritance

When you use the RSR template:

1. CI automatically inherits parent compliance checks
2. New projects start with inherited reputation
3. Deviations require explicit justification

=== Implementation Path

[cols="1,3,1", options="header"]
|===
| Task | Description | Priority

| Trust Graph Schema
| Define JSON-LD schema for project relationships
| P0

| Sigstore Integration
| Keyless signing for all attestations
| P0

| Reputation API
| Public API for querying project trust scores
| P1

| GitHub App
| Bot for automated compliance checking and badge updates
| P1

| Dependency Scanning
| Deep analysis of transitive dependencies for RSR compliance
| P2
|===

---

== Phase 2: Consent Protocol (v3.0 â†’ v5.0)

=== Vision

Implement the full Consent-Aware HTTP specification. Projects can actually *enforce* consent requirements, not just declare them.

=== v3.0: Consent Middleware

==== Reference Implementation

A Rust library (with WASM bindings) that any server can integrate:

[source,rust]
----
use consent_aware_http::{ConsentMiddleware, ConsentLevel};

let consent = ConsentMiddleware::builder()
    .require_level(ConsentLevel::AiTraining, ConsentAction::RequireToken)
    .require_level(ConsentLevel::Commercial, ConsentAction::RequireConsent)
    .require_level(ConsentLevel::Attributed, ConsentAction::RequireAttribution)
    .build();

// Returns HTTP 430 Consent Required if consent headers missing
app.layer(consent);
----

==== Consent Token Registry

Centralised (initially) registry for consent tokens:

[source]
----
https://consent.rhodium.sh/tokens/
â”œâ”€â”€ issue      # Request a consent token
â”œâ”€â”€ verify     # Verify a token
â”œâ”€â”€ revoke     # Revoke granted consent
â””â”€â”€ audit      # Audit trail of consent usage
----

=== v4.0: Consent Federation

Decentralise the consent registry:

* Multiple consent authorities (like Certificate Authorities)
* Cross-authority token verification
* Consent portability between platforms

=== v5.0: HTTP 430 RFC Submission

* Submit formal RFC for HTTP 430 Consent Required
* Reference implementation in major web servers (nginx, Caddy)
* Browser support for consent headers
* Integration with robots.txt successor (ai.txt)

=== Implementation Path

[cols="1,3,1", options="header"]
|===
| Task | Description | Priority

| Consent Token Spec
| Define token format, issuance, verification
| P0

| Rust Middleware
| Reference implementation in Rust
| P0

| WASM Bindings
| Enable browser-side consent verification
| P1

| Registry Service
| Initial centralised registry (Elixir/Phoenix)
| P1

| Federation Protocol
| Multi-authority consent verification
| P2

| RFC Draft
| Formal IETF submission
| P2

| Browser Extension
| Automatic consent header injection
| P3
|===

---

== Phase 3: Provenance Chain (v6.0 â†’ v8.0)

=== Vision

Full supply chain transparency. Every commit, every dependency, every build step is cryptographically attested and publicly verifiable.

=== v6.0: SLSA Level 4

Achieve SLSA Level 4 (hermetic, reproducible builds):

[source]
----
Source â†’ Build â†’ Attest â†’ Publish â†’ Verify
   â†“        â†“        â†“         â†“        â†“
  GPG    Guix     Sigstore   OCI    SLSA
 signed  hermetic  log      signed  verified
----

==== Reproducible Builds

All RSR projects must be reproducibly buildable:

[source,bash]
----
# Build on any machine, get identical output
guix build -f guix.scm

# Verify against attestation
slsa-verifier verify-artifact \
  --provenance-path attestation.intoto.jsonl \
  --source-uri github.com/hyperpolymath/project
----

=== v7.0: Dependency Provenance

Track provenance of all transitive dependencies:

[source,json]
----
{
  "dependency": "serde@1.0.195",
  "provenance": {
    "source": "https://github.com/serde-rs/serde",
    "commit": "abc123...",
    "buildLog": "https://crates.io/builds/serde/1.0.195",
    "attestation": "sigstore.dev/log/12345",
    "rsrCompliance": {
      "tier": 1,
      "score": 9.8
    }
  }
}
----

=== v8.0: Decentralised Provenance

Move from centralised attestation to decentralised verification:

* Provenance records stored in content-addressed storage (IPFS/Iroh)
* Cross-platform verification (GitHub, GitLab, Codeberg, Sourcehut)
* No single point of trust failure

=== Implementation Path

[cols="1,3,1", options="header"]
|===
| Task | Description | Priority

| Guix Integration
| All RSR projects buildable via Guix
| P0

| SLSA Generator
| GitHub Action for SLSA attestation
| P0

| Dependency Scanner
| Deep provenance analysis of dependencies
| P1

| Provenance Explorer
| Web UI for exploring provenance chains
| P2

| IPFS Storage
| Decentralised attestation storage
| P2

| Cross-Forge Verification
| Verify attestations across forges
| P3
|===

---

== Phase 4: Formal Verification (v9.0)

=== Vision

For critical code paths, move beyond testing to mathematical proof. RSR projects can include SPARK proofs, Coq specifications, or TLA+ models.

=== Verification Tiers

[cols="1,2,2", options="header"]
|===
| Tier | Requirement | Verification

| Bronze
| Property-based testing
| QuickCheck/Hypothesis style tests

| Silver
| Design-by-contract
| Ada/SPARK contracts, Rust invariants

| Gold
| Formal specification
| TLA+, Alloy, or Z specifications

| Platinum
| Machine-checked proofs
| Coq, Lean, Isabelle proofs
|===

=== Integration Points

* CI validates that specifications match implementation
* Proofs are part of the provenance chain
* Formal specs are versioned alongside code

=== Implementation Path

[cols="1,3,1", options="header"]
|===
| Task | Description | Priority

| SPARK CI Integration
| Validate Ada/SPARK contracts in CI
| P1

| TLA+ Toolbox
| CI for TLA+ model checking
| P2

| Coq/Lean Integration
| Proof verification in CI
| P2

| Spec-to-Code Linking
| Link formal specs to implementation
| P3
|===

---

== Phase 5: The Endgame (v10.0+)

=== Vision

RSR becomes invisible infrastructureâ€”the default way software is built.

=== v10.0: Self-Sovereign Software

[quote, The Promise]
____
Any developer, anywhere, can verify any claim about any software, without trusting any single authority.
____

==== Properties

* *Decentralised Trust*: No central authority required for verification
* *Portable Identity*: Developer reputation moves with them across platforms
* *Automatic Compliance*: Tools enforce policies without manual intervention
* *Universal Provenance*: Every byte traceable to its origin

==== Architecture

[plantuml, v10-architecture, svg]
....
@startuml
!theme plain
skinparam backgroundColor transparent

cloud "Developer Ecosystem" {
  actor "Developer" as dev

  package "Local Tools" {
    [Editor\nLSP Plugin] as lsp
    [Pre-commit\nHooks] as hooks
    [Guix/Nix\nEnvironment] as env
  }
}

cloud "Verification Network" {
  package "Trust Layer" {
    [Consent\nFederation] as consent
    [Provenance\nChain] as prov
    [Reputation\nGraph] as rep
  }

  database "Decentralised\nStorage" as ds
}

cloud "Consumer Ecosystem" {
  actor "User" as user
  [Application] as app
  [Verification\nLibrary] as verify
}

dev --> lsp
dev --> hooks
dev --> env

hooks --> consent : register
env --> prov : attest
lsp --> rep : check

consent --> ds : store
prov --> ds : store
rep --> ds : query

user --> app
app --> verify
verify --> ds : verify
@enduml
....

=== Beyond v10.0: Research Directions

==== Language Server Ecosystem

LSP servers that enforce RSR policies in real-time:

* Inline warnings for language policy violations
* Consent requirement hints
* Dependency reputation scores
* Automatic attestation generation

==== AI Governance Layer

RSR as the foundation for ethical AI development:

* Consent-aware training data
* Provenance-tracked model weights
* Verifiable AI supply chains

==== Cross-Language Formal Methods

Unified formal specification across RSR languages:

* Rust contracts â†” Ada/SPARK â†” Haskell types
* Automatic property translation
* Cross-language proof portability

---

== Timeline (Aspirational)

[IMPORTANT]
====
These are aspirational milestones, not commitments. Development is driven by community contribution and real-world needs.
====

[cols="1,2,3", options="header"]
|===
| Version | Focus | Key Deliverables

| v1.0 (Q1 2026)
| Foundation
| Complete template, justfile, Containerfile, flake.nix

| v2.0 (Q3 2026)
| Trust Network
| Compliance attestation, reputation graph, GitHub App

| v3.0 (Q1 2027)
| Consent Middleware
| Rust library, WASM bindings, initial registry

| v4.0 (Q3 2027)
| Consent Federation
| Multi-authority tokens, portability

| v5.0 (Q1 2028)
| HTTP 430 RFC
| IETF submission, nginx/Caddy support

| v6.0 (Q3 2028)
| SLSA Level 4
| Reproducible builds, full attestation

| v7.0 (Q1 2029)
| Dependency Provenance
| Transitive dependency tracking

| v8.0 (Q3 2029)
| Decentralised Provenance
| IPFS storage, cross-forge verification

| v9.0 (Q1 2030)
| Formal Verification
| SPARK/TLA+/Coq integration

| v10.0 (2030+)
| Self-Sovereign Software
| Complete decentralised trust infrastructure
|===

---

== How to Contribute

This roadmap is ambitious. It requires:

* *Rust developers* for consent middleware
* *Elixir developers* for registry services
* *Guix/Nix packagers* for reproducible builds
* *Formal methods experts* for verification integration
* *Security researchers* for threat modelling
* *Technical writers* for documentation
* *Standards experts* for RFC drafting

See link:CONTRIBUTING.md[CONTRIBUTING.md] to get started.

=== Priority Areas

1. *Immediate*: justfile recipes, pre-commit hooks, documentation
2. *Short-term*: Compliance attestation, GitHub App
3. *Medium-term*: Consent middleware, federation protocol
4. *Long-term*: Formal verification, decentralised storage

---

== References

* https://slsa.dev[SLSA Framework]
* https://sigstore.dev[Sigstore]
* https://guix.gnu.org/manual/en/html_node/Invoking-guix-build.html[Guix Build System]
* https://www.adacore.com/about-spark[SPARK Formal Verification]
* https://lamport.azurewebsites.net/tla/tla.html[TLA+ Specification Language]
* https://www.rfc-editor.org/rfc/rfc9116[RFC 9116: security.txt]
* https://ipfs.tech[IPFS]
* https://iroh.computer[Iroh]

---

[.text-center]
_The future of software is verifiable, consent-aware, and trustworthy by default._

[.text-center]
Version History: 2025-12-23 (v0.2.0) â€¢ Initial vision document
